Functional languages historically have been very notable in the world of scientific computing. Of course, taking a list of the most popular languages for scientific computing today, it would be obvious that they are all multi-paradigm.

I do not what I'm studing is correct, but it's what a doing

- I read this file first: https://towardsdatascience.com/what-is-a-programming-paradigm-1259362673c2
    - A great way to think about a paradigm is as a set of ideas that a programming language can use to perform tasks in terms of machine-code at a much higher level.

## Important to know and understand the differences about ***Declarative Vs Imperative***

## Declarative Programming

Declarative programming is when the programmer behind the wheel isn’t effectively programming exactly what a computer does at any given moment — but instead describes properties of the result they want while not explaining how to compute it. Some examples of paradigms that fall into this window are:

-   The functional programming paradigm.
-   The logical programming paradigm.
-   The mathematical programming paradigm.
-   The modular programming paradigm.
___
## Imperative Programming

Imperative programming is essentially the opposite of declarative programming. Firstly, with imperative programming the user is typically interacting directly with the state of the computer, and deciding how things are to be calculated. Some examples of paradigms that popularized this method of programming are:

-   The object-oriented programming paradigm.
-   The procedural programming paradigm.

___
## Paradigm applications

It is important to remember that languages do not need to conform to these rules. Although C++ is often wrongfully credited with creating the object-oriented programming paradigm, it certainly did bring one amazing concept into play in the programming world:

> Generics!
> Generics allow programming languages to pick-and-choose certain attributes from various programming paradigms and utilize the ones that might apply best to the application of the language. Prior to the introduction of generics, most languages were created to perform very specific operations. For example, Simula, the real first object-oriented programming language was created specifically for running complex simulations. Another great example is COBOL, which is a programming language mostly used in business applications.

___
The simple reality is that there is a lot about programming — and computers, in general — that a functional programming language can teach you. This is of course true with imperative languages such as C, object-oriented languages like Python and C++, and even the stranger paradigms like the structural programming paradigm
___
Here is a list of languages that I like and know that could teach you about programming in their respective paradigm:

## Functional

-   Common Lisp
-   Scheme
-   Haskell
-   R
-   Julia
-   Nimrod

## Object-oriented

-   C++
-   C#(CSharp) 
-   Java
-   JavaScript
-   Python
-   Scala

Good example I have seen this days, it is in OOP, the class can have functions (a.k.a methods) inside him, different a `struct` in C when only can have a data types

## Imperative

-   C
-   Assembly (I personally use NASM/FASM and only the 64-bit registries (amd64 Assembly))
-   FORTRAN

___
# Conclusion

All programming paradigms have their benefits to both education and ability. Functional languages historically have been very notable in the world of scientific computing. Of course, taking a list of the most popular languages for scientific computing today, it would be obvious that they are all multi-paradigm. Object-oriented languages also have their fair share of great applications. Software development, game development, and graphics programming are all great examples of where object-oriented programming is a great approach to take.

The biggest note one can take from all of this information is that the future of software and programming language is multi-paradigm. It is unlikely that anyone will be creating a purely functional or object-oriented programming language anytime soon. If you ask me, this isn’t such a bad thing, as there are weaknesses and strengths to every programming approach that you take, and a lot of true optimization is performing tests to see which methodology is more efficient or better than the other overall. This also puts a bigger thumbtack into the idea that everyone should know multiple languages from multiple paradigms. With the paradigms merging using the power of generics, it is never known when one might run into a programming concept from an entirely different programming language!

## In the CS50 harvard course.

They said `Up until now, in C, we've been focusing on what's called, really, procedural programming.` We write procedures, we write fuunction, top to bottom, left to right.